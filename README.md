# Problem description

Please submit the complete C++ source code for a program that counts the number of distinct unique words in a file whose name is passed as an argument to a program. For example, given the file content "a horse and a dog" the program must output "4" (the word 'a' appears twice but only accounts for one distinct unique occurrence).
The input text is guaranteed to contain only 'a'..'z' and space characters in ASCII encoding. The program should be able to handle large inputs (e.g. 32 GiB). You can assume that all unique words fit into memory when using the data structure of your choice. The solution must utilize all available CPU resources.

# Build
```
mkdir build && cd build && cmake -DCMAKE_BUILD_TYPE=Release .. && cmake --build . --parallel
```

# Test data generation

Data for tests can be generated by the following command:
```
# ./data_generator <file_size_in_bytes> <number_of_unique_words>
./data_generator 10000 100
```

# Solution description

`unique_words_counter` target accepts file path to the file with words as an input:
```
./unique_words_counter file_2000.txt
2000
```

The application executes the following steps:
1. Check the file size to find the appropriate memory limit for internal buffer.
2. Knowing the buffer size and appropriate number of threads, it finds the boundaries of the blocks to be between words.
3. Spawn a thread pool.
4. Read using file stream into the buffer of known block size and keep track on total size of allocated buffers using atomic integer counter.
5. Each buffer is move-captured by lambda function as a job for thread pool.
6. The buffer is processed by splitting it into words and pushing each word into thread-safe hash set. After processing buffer is cleared and buffer size counter is decreased and the IO thread is notified using condition variable. 
7. The size of the set is printed out as the number of unique words.

## Containers

3 types of hash set containers were tried:

1. Simple mutex-protected `std::unordered_set`: `ThreadSafeHashSet`
```
cmake -DCMAKE_BUILD_TYPE=Release -DUSE_BOOST_HASH_SET=OFF -DUSE_ALPHABET_OPTIMIZATION=OFF ..
```
2. Mutex-protected `std::unordered_set` with "alphabet optimization": `ThreadSafeHashSet<std::string>` template specialization.
   
   "Alphabet optimization" is simply a trick to prevent a contention on a single mutex for many threads. Instead, 27 separate unordered sets are created, each protected by its own mutex. Each string then is put into its own hash set based on the first character value. The total count of elements is then a sum of all sets counts.
```
cmake -DCMAKE_BUILD_TYPE=Release -DUSE_BOOST_HASH_SET=OFF -DUSE_ALPHABET_OPTIMIZATION=ON ..
```
3. `boost::concurrent_flat_set` 
```
cmake -DCMAKE_BUILD_TYPE=Release -DUSE_BOOST_HASH_SET=ON -DUSE_ALPHABET_OPTIMIZATION=OFF ..
```

# Results

Results are from the output of `performance_test.sh` (time measured in seconds).

| Container                                      | 100Mb | 1Gb  | 5Gb  |
|------------------------------------------------|-------|------|------|
| `std::unordered_set` + `std::mutex`            | 0.76  | 5.7  | 29.6 |
| `std::unordered_set` + "alphabet optimization" | 0.5   | 1.4  | 7.5  |
| `boost::concurrent_flat_set`                   | 0.18  | 0.98 | 4.75 |

## `pprof`

```
CPUPROFILE=prof.out ./unique_words_counter file_10000.txt


Total: 591 samples
     198  33.5%  33.5%      364  61.6% std::__1::getline[abi:ue170006]
      83  14.0%  47.5%      514  87.0% UniqueWordsCounter::split_words_and_insert
      50   8.5%  56.0%       50   8.5% 0x00000001834c4160
      47   8.0%  64.0%       47   8.0% 0000000183433fe4
      31   5.2%  69.2%       31   5.2% 0000000183433f5c
      26   4.4%  73.6%       26   4.4% 0x00000001835331f8
      23   3.9%  77.5%       23   3.9% UniqueWordsCounter::split_words_and_insert 
      20   3.4%  80.9%       20   3.4% boost::unordered::detail::foa::rw_spinlock::lock_shared
      18   3.0%  83.9%       18   3.0% 0x00000001834c4e78
      17   2.9%  86.8%       17   2.9% 0000000183433fb0
```