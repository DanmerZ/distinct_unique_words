# Problem description

Please submit the complete C++ source code for a program that counts the number of distinct unique words in a file whose name is passed as an argument to a program. For example, given the file content "a horse and a dog" the program must output "4" (the word 'a' appears twice but only accounts for one distinct unique occurrence).
The input text is guaranteed to contain only 'a'..'z' and space characters in ASCII encoding. The program should be able to handle large inputs (e.g. 32 GiB). You can assume that all unique words fit into memory when using the data structure of your choice. The solution must utilize all available CPU resources.

# Build
```
mkdir build && cd build && cmake -DCMAKE_BUILD_TYPE=Release .. && cmake --build . --parallel
```

# Test data generation

Data for tests can be generated by the following command:
```
# ./data_generator <file_size_in_bytes> <number_of_unique_words>
./data_generator 10000 100
```

# Solution description

`unique_words_counter` target accepts file path to the file with words as an input:
```
./unique_words_counter file_2000.txt
2000
```

The application executes the following steps:
1. Check the file size to find the appropriate memory limit for internal buffer.
2. Knowing the buffer size and appropriate number of threads, it finds the boundaries of the blocks to be between words.
3. Spawn a thread pool.
4. Read using file stream into the buffer of known block size and keep track on total size of allocated buffers using atomic integer counter.
5. Each buffer is move-captured by lambda function as a job for thread pool.
6. The buffer is processed by splitting it into words and pushing each word into thread-safe hash set. After processing buffer is cleared and buffer size counter is decreased and the IO thread is notified using condition variable. 
7. The size of the set is printed out as the number of unique words.

## Containers

3 types of hash set containers were tried:

1. Simple mutex-protected `std::unordered_set`: `ThreadSafeHashSet`
```
cmake -DCMAKE_BUILD_TYPE=Release -DUSE_BOOST_HASH_SET=OFF -DUSE_ALPHABET_OPTIMIZATION=OFF ..
```
2. Mutex-protected `std::unordered_set` with "alphabet optimization": `ThreadSafeHashSet<std::string>` template specialization.
   
   "Alphabet optimization" is simply a trick to prevent a contention on a single mutex for many threads. Instead, 27 separate unordered sets are created, each protected by its own mutex. Each string then is put into its own hash set based on the first character value. The total count of elements is then a sum of all sets counts.
```
cmake -DCMAKE_BUILD_TYPE=Release -DUSE_BOOST_HASH_SET=OFF -DUSE_ALPHABET_OPTIMIZATION=ON ..
```
3. `boost::concurrent_flat_set` 
```
cmake -DCMAKE_BUILD_TYPE=Release -DUSE_BOOST_HASH_SET=ON -DUSE_ALPHABET_OPTIMIZATION=OFF ..
```

# Results

Results are from the output of `performance_test.sh` (time measured in seconds).

| Container                                      | 100Mb | 1Gb  | 5Gb  |
|------------------------------------------------|-------|------|------|
| `std::unordered_set` + `std::mutex`            | 0.76  | 5.7  | 29.6 |
| `std::unordered_set` + "alphabet optimization" | 0.5   | 1.4  | 7.5  |
| `boost::concurrent_flat_set`                   | 0.18  | 0.98 | 4.75 |

